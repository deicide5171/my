<Web & Network>
0. Web Service
	- Client(PC, Web Browser 등)가 HTTP 통신을 통해 원하는 데이터(텍스트, 이미지, 미디어 등)를 요청하고 Server에서 해당 데이터를 정적/동적으로 HTTP 통신을 통해 응답해주는 서비스
	
1. Web Server / Web Application Server
	- Web Server : Apache     // 요새는 WAS에 기능이 포함된다.
		- 소프트웨어 : 브라우저 클라이언트로부터 HTTP 요청을 받아들이고 HTML 등의 웹페이지 문서에 반응하는 컴퓨터 프로그램(정적인 처리로 빠르고 안정성이 높다)
		- 하드웨어 : Web Server가 설치되어 있는 컴퓨터
	- Web Application Server(WAS) : tomcat, web logic, web sphere, jeus
		- HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진). 동적 서버 컨텐츠를 수행. 주로 DB와 통신한다.(작업시간이 좀 걸리고 오류가 발생할수도 있다.)

2. Servlet vs JSP
	- Servlet : Server(= Tomcat)에서 동적으로 웹페이지를 생성하는 Java Program. Java Source에서 HTML을 일일히 작성하는 번거로움이 존재.
	- JSP(Java Server Page) : Servlet의 번거로움을 해결하고자 HTML안에 Java Source Code를 블록화하여 삽입한 Program. WAS에서 Servlet Code(=Java Code .java)로 변환되어 Servlet처리와 마찬가지로 컴파일(.class)되고 메모리에 적재되어 HTTP Get, Post등의 요청을 처리한다.

3. Model 1 vs Model 2	
	- Model 1 : Servlet만 또는 JSP만 사용하는 형태. 한군데에서 개발되어 개발속도는 빠르지만 프레젠테이션 로직, 비지니스 로직 모두가 모여있어 가독성, 운영면에서 단점을 보여준다.
	- Model 2 : Model 1의 단점을 보완하고자 고안된 JSP의 장점과 Servlet의 장점을 결합한 형태. View(프레젠테이션 로직)는 JSP로, Controller(비지니스 로직)는 Servlet으로 개발. 그리고 Model 영역 에서는 DTO, DAO를 통해 DB에 접근한다.
	
4. HTTP(HyperText Transfer Protocol : 인터넷 통신 규약 프로토콜 // 웹 브라우저와 웹 서버 사이의 데이터 통신 규약) 호출
	- Get
		- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "?"이후로 "이름"과 "값"이 결합된 스트링 형태로 전달 (?aName=a&bName=b)
		- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.
		- 길이에 제한이 있다.(=전송 데이터의 한계가 있다.) // IE를 제외한 나머지 Browser에서는 전송 데이터의 한계가 없다.
		- Post방식보다 상대적으로 전송 속도가 빠르다.
		- Select
	- Post
		- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.
		- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.
		- 주소창에 전송하는 데이터의 정보가 노출되지 않고 HTTP Body에 포함되어 전달되어 Get방식에 비해 보안성이 높다.
		- 속도가 Get방식보다 느리다.
		- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.
		- Update
	- Put
		- Insert
	- Delete
		- Delete

5. Session vs Cookie
	- Session과 Cookie 사용 이유
		- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.
	- Session
		- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
		- Session에 관련된 데이터는 Server에 저장된다.
		- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
		- Cookie에 비해 보안성이 좋다.
		- 모든 정보를 Session에 저장하다보면 Server의 메모리를 과도하게 사용하여 장애가 발생할 수도 있다.
	- Cookie
		- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법
		- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
		- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
		- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)

6. Web Cache : Clinet의 요청시 응답되는 파일을 내려받아 특정 위치에 복사본으로 저장하여 이후에 오는 동일한 요청에 대해 다시 내려받는 과정을 생략하고 응답한다. = 응답시간 감소, 트래픽 감소
	- Browser Cache
	- Proxy Cache
	- Gateway Cache

7. Ajax 문법
	$.ajax({
		url: '', // 주소
		type: '', // get방식, post방식
		data: '', // 파라미터
		dataType: '', // 받을때 데이터 형식
		Async: '', // 비동기 통신 플래그 : true가 비동기, false가 동기  - 동기는 모든 처리가 끝난 후 다음 처리로 넘어간다. 비동기는 동시에 한다.
		sucssess: function(response){
			// 성공적으로 통신이 이루어졌을 때 처리하고 싶은 함수
		},
		error: function(error){
			// 에러가 발생하였을 때 처리하고 싶은 함수
		} 
	});

8. html doctype? : 웹페이지 문서 종류가 HTML5라고 알려주는 선언문으로 가장 처음에 선언되어야 하는 것이다.

9. Sync(동기) vs ASync(비동기)
	- 동기 : 통신에 참여하는 모든 노드가 시간을 동기화해서 전송(순서대로 시간을 정해놓고 동작. 통신을 완료하거나 제한시간이 지나면 다음 동작으로 넘어감)
	- 비동기 : 시간 동기를 맞추지 않는 대신 전송전에 노드간의 연결을 확인하고 맺는 과정 진행(오버헤드 발생) 후 통신

10. OSI 7 : Open System Interconnection : 네트워킹 또는 무선통신 시스템의 기능을 설명하는 핵심 개념
	7계층 - 응용 계층(Application) : 사용자에게 보여지는 부분. 즉 사용자에게 가장 가까운 계층. ex> 크롬, 파이어폭스 등의 웹 브라우저 + 스카이프, 아웃룩, 오피스 등의 응용프로그램 / FTP / Telnet
	6계층 - 표현 계층(Presentation) : 응용프로그램이나 네트워크를 위해 데이터를 "표현"하는 계층. ex> 데이터의 암호화, 복호화가 이루어짐.
	5계층 - 세션 계층(Session) : 2대의 기기, 컴퓨터 또는 서버간의 "대화"가 필요하면 세션(Session)을 만들어야 하는데 이 작업이 여기서 처리된다. 설정, 시스템응답대기기간, 세션 마지막에 응용프로그램 간의 종료 등의 기능 수행
	4계층 - 전송 계층(Transport) : 최종 시스템 및 호스트 간의 데이터 전송 조율을 담당. 보낼 데이터의 용량과 속도, 목적지 등을 처리한다. ex> TCP(Transport Control Port)/IP(Internet Protocol), Socket, UDP
	3계층 - 네트워크 계층(Network) : 네트워킹 전문가 대부분이 관심을 두고 좋아하는 라우터 기능 대부분이 여기 네트워크 계층에 자리잡는다. 다른 여러 라우터를 통한 라우팅을 비롯한 패킷 전달을 담당. IP
	2계층 - 데이터 링크 계층(Data Link) : 노드 간 데이터 전송을 제공. 물리 계층의 오류 수정도 처리. MAC, LLC 계층, 스위치는 여기서 동작
	1계층 - 물리 계층(Physical) : 시스템의 전기적, 물리적 표현을 나타낸다. 케이블의 종류, 무선 주파수 링크, 핀 배치, 전압, 물리 요건 등. 물리 계층에서의 네트워킹 문제는 케이블 연결여부, 라우터나 스위치 또는 컴퓨터의 전원 여부를 확인한다.
	** All People Seem To Need Data Processing (A - P - S - T - N - D - P)
	
11. 웹사이트 연결 과정
	웹 브라우저(=Client)에서 URL 입력하여 요청(=Request) -> 패킷단위로 전송 -> DNS서버에서 도메인과 IP주소 맵핑 -> 확인된 IP주소로 Redirect -> 해당 IP주소의 웹 서버에서 요청 처리(미디어자료 or 미들웨어에서 데이터 정제 or DB에서 데이터 조회) -> 결과값(미디어자료, JSON/XML 등)을 응답(=Response) -> 결과값을 웹 브라우저에 노출.

12. TCP/IP
	- 설명 : 인터넷 표준 프로토콜로 컴퓨터의 데이터 통신을 행하기 위해서 만들어진 프로토콜 체계IP(Internet Protocol)의 핵심 프로토콜로 TCP/IP라 불린다.
	- 근거리 통신망, 인트라넷, 인터넷에 연결된 컴퓨터간의 데이터 교환을 순서대로 에러없이 실행시켜준다.
	- 웹브라우저가 WWW의 서버에 연결 할 때 사용되며, 이메일이나 파일전송에도 사용된다.
	- 양뱡향 전송

13. 패킷 : 네트워크를 통해 전송하기 쉽도록 자른 데이터의 전송단위

<2 제곱>
2^10 = 1024 = 1KB
2^16 = 65,536 = 64KB
2^20 = 1,048,536 = 1MB
2^30 = 1,073,741,824 = 1GB
2^32 = 4,294,967,296 = 4GB
2^40 = 1,099,511,627,776 = 1TB

14. 소켓 통신(TCP/UDP)
	- TCP(Transmission Control Protocol)
		- 연결형 서비스 제공
		- 높은 신뢰성 보장
		- 연결의 설정(3-way handshaking)
		- 연결의 해제(4-way handshaking)
		- 데이터 흐름 제어, 혼잡 제어
		- 전이중, 점대점 서비스(양방향 송수신 서비스)

	- UDP(User Datagram Protocol)
		- 비연결형 서비스 제공
		- 신뢰성이 낮음
		- 데이터의 전송 순서가 바뀔 수 있음
		- 데이터 수신 여부 확인 안함(3-way handshaking과 같은 과정 X)
		- TCP보다 전송속도가 빠름



<Java>
– 자바란 무엇인가요
자바란 객체지향 프로그래밍 언어로써 가장 중요한 특징은 운영체제에 독립적이란 것입니다. 자바로 작성된 프로그램은 운영체제의 종류에 관계없이 실행이 가능합니다. 그 이유는 자바를 실행하기 위한 가상 머신인 JVM이 있기 때문입니다. 다른 애플리케이션은 프로그램 실행 시 바로 OS로 가는 반면 자바 애플리케이션은 각 운영체제에 맞는 JVM을 거쳐 OS로 진행되기 때문에 프로그램 수정 없이 실행 가능합니다.

JAVA는 네트워크상에서 쓸 수 있도록 미국의 선 마이크로 시스템즈가 개발한 객체 지향 프로그래밍 언어

JAVA의 특징
a. 자바가상머신(JVM)만 설치하면 컴퓨터의 운영체제에 상관없이 작동한다.(즉, 운영체제에 독립적)
b. 기본 자료형을 제외한 모든 요소들이 객체로 표현
c. 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
d. Garbage Collector를 통한 자동적인 메모리 관리
e. 멀티쓰레드(Multi-thread)를 지원

– JDK란 무엇인가요
자바 프로그램 개발도구로써 개발을 위한 클래스, 컴파일러, 실행 및 배포도구를 포함하여 개발을 위한 전반적인 환경을 제공하는 것입니다.

– OOP란? 객체 지향 언어란?
객체 지향 프로그래밍를 의미합니다. 가장 중요한 특징은 캡슐화, 상속, 다형성입니다. 객체 지향 프로그래밍을 하게 되면 클래스라는 개념을 도입함으로써 코드의 재사용을 할 수 있습니다.

1. 객체지향 프로그래밍(Object Oriented Programing : OOP) 개념
	OOP란 Object-Oriented Programming의 약어로써 객체지향 프로그래밍을 의미

데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는
다르게 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말한다.

OOP 특징
a. 객체지향 프로그래밍은 코드의 재사용성이 높다.
b. 코드의 변경이 용이
c. 직관적인 코드분석
d. 개발속도 향상
e. 상속을 통한 장점 극대화

	- Class(클래스) : Object의 Template. Data + Method
	- Object(객체) : Class의 Instance
		Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념

예)기차역에서 승차권을 발매하는 경우, 실체인 '손님'과 동작인 '승차권 주문'은 하나의 객체이며, 실체인 '역무원'과
동작인 '승차권 발매'도 하나의 객체이다.
같은 성질, 같은 구조와 형태를 가지는 객체는 등급으로 정의하고 등급에 속하는 객체는 그 등급의 인스턴스라고 한다.

- Encapsulation : 캡슐화. Class의 보안유지. Class내의 Data + Method를 외부에서의 변화시도로부터 안전하게 지킨다.
- Inheritance : 상속. Parent-Child( [부모의 Data + Method] + [본인의 Data + Method] ). 코드의 재사용성을 높여준다.
- Abstraction : 추상화. 가상화. 가상클래스에서 함수명만 표시(클래스 설계시 설계자가 가상클래스 생성. 개발자가 자식클래스에 구현.). 가상클래스의 자식클래스(=구현클래스)에서 부모의 함수들에 대한 동작이 구현되어있다.(overriding)
- Polymorphism : 다형성. 같은 이름의 Method들이 각각 다른 동작을 한다. Overloading(함수명 같고, 파라미터값에 따라 다른 동작), Overriding(부모 자식간에 다른 행동을 하는 같은 이름의 함수)
* 캡상추다

– 오버라이딩이란 무엇인가요
부모 클래스에게 상속 받은 것들을 다시 자신의 클래스에서 새로이 재정의 하는 것을 말합니다. 재정의 한 것은 자신의 클래스 내부에서만 영향을 끼치며 부모클래스에서는 영향을 끼치지 않습니다. 할머니클래스, 부모클래스, 자식클래스의 구조라면 자식클래스는 할머니,부모 클래스의 것들을 모두 상속 받을 수 있으며, 할머니와 부모클래스의 같은 변수가 있다면 부모클래스를 물려 받게 됩니다.

– 오버로딩이란 무엇인가요
상속이 아닌 하나의 클래스 내에서 이름이 같은 여러개의 메서드를 정의하는 것입니다. 이름이 같기 때문에 호출 시에 구분 방법은 매개변수입니다. 매개변수의 수, 배치(순서), 타입 이 달라야 합니다.

– 상속이란 무엇인가요
기존 클래스의 기능을 유지하면서 추가적인 기능을 추가하여 클래스를 만들고 싶을 때 사용하는 방법은 상속입니다. 새로운 클래스를 생성할 때 상위 클래스를 지정함으로써, 상위 클래스의 모든 기능, 속성을 제공받고 자신의 클래스에는 부가적인 기능, 속성을 추가 할 수 있습니다. 상속은 코드를 간결화하며, 재사용성을 높일 수 있습니다.

– 자바의 데이터 타입에 대해 설명하시오 (Primitive type , Reference type)
기본형은 실제 값을 저장하는 공간을 말하며 종류는 8가지가 있습니다. 이외의 모든 타입을 참조형 이라고 하며 실제 값이 저장된 곳의 주소를 저장하는 공간을 의미합니다.

– 다형성이란 무엇인가요
하나의 클래스나 함수가 다양한 방식으로 동작이 가능한 것을 말합니다. 하나의 메시지가 전달되었을 때 수신자가 누구냐에 따라 각각 다른 기능을 수행합니다. 자바에서 오버로딩, 오버라이딩 등이 있습니다. 쉽게 예를 들면 저는 하나이지만 학교에 있으면 학생이고 집에서는 아들이라는 구성원입니다. 이렇게 생각하면 쉽다고 생각합니다.

– 쓰레드란 무엇인가요
자바 프로그램을 구성하는 명령문은 순서대로 하나씩 처리되는 것이 기본입니다. 이러한 실행흐름을 쓰레드라고 합니다. 둘 이상의 흐름을 갖도록 만들고 싶다면 멀티 쓰레드 프로그램을 사용하면 됩니다.

– 멀티쓰레드란? 장점은 무엇인가요
하나의 프로그램에서 둘 이상의 작업이 필요로 할 때 사용합니다. 자원을 효율적으로 사용가능하며 작업이 분리되어 코드가 간결해 집니다.

– 쓰레드 생성방법이 무엇인가요
첫 번째로는 쓰레드 클래스를 상속받거나 인터페이스를 구현 받는 방법이 있습니다. 두 번째로는 구현한 클래스 내부에서 인스턴스 생성 즉시 쓰레드를 생성시키는 방법이 있습니다.

– 추상클래스란 무엇인가요
하나이상의 추상메서드를 포함한 클래스입니다. 추상클래스는 객체를 생성 할 수 없으며 멤버변수, 일반 메서드, 상수 등도 가질 수 있습니다.

– 인터페이스란 무엇인가요
클래스가 상속을 통해 구현하기에 한계가 있는 경우, 자바에서 불가능한 다중상속을 흉내내기 위한 도구로써 사용됩니다. 추상클래스보다 추상정도가 높으며 추상메서드와 상수만을 가질 수 있습니다. Implements를 통해 구현합니다.

Interface
- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

Abstract
- 추상메서드를 하나 이상 가진 클래스
- 자신의 생성자로 객체 생성 불가능
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용

Interface vs Abstract
공통점 
- new 연산자로 인스턴스 생성 불가능.
- 프로토타입만 있는 메서드를 갖는다.
- 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.
차이점
- 사용하는 키워드가 다르다.
- Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.

– 디자인패턴이란 무엇인가요
설계시 반복적으로 나타나지는 설계 방법 또는 구조들을 말합니다. 디자인패턴을 이용하게 되면 코딩이 명확하고 단순하며 모듈을 세분화 시킬 수 있고, 재사용성이 높으며 유지보수가 쉬워집니다. 디자인패턴은 대표적으로 GoF 23가지 패턴이 있습니다. 패턴들의 대부분의 공통점은 추상클래스나 인터페이스로부터 상속받은 클래스를 사용하며, 이는 객체지향의 다형성을 이용한 방법입니다.

– 메모리 상수풀 영역 이란
힙영역(프로그래머가 관리하는 메모리 영역)에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역입니다. 기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴합니다. 그로 인해 메모리 절약 효가가 있습니다.

– main메서드는 왜 static인가요?
static은 메모리 선언을 사용하지 않아도 사용할 수 있습니다. main메서드는 자바가상머신(JVM)에 의해 호출되는 것이므로 반드시 static으로 선언되어 미리 올라가 있어야 합니다. 만일 메모리에 있지 않다면 시작점인 main메서드를 호출하려고 할 때 메모리에 없기 때문에 실행되지 않습니다.

– 캡슐화란 무엇인가요
관련된 데이터와 메서드를 하나의 단위로 묶는 원리입니다. 그로 인해 캡슐내부와 외부를 구별하게 됩니다. 캡슐화를 하게 되면 클래스의 필드 값에 권한을 설정할 수 있습니다. 또한 사용자는 데이터가 클래스에 어떻게 저장되는지 알 수 없습니다. 그리고 클래스의 결합도가 낮아져 재사용이 용이하게 됩니다.

– 직렬화란 무엇인가요
메모리에 있는 객체를 보조기억장치에 저장할 수 있도록 바이트 형태로 변환하는 것을 말합니다. 객체가 생성되어 데이터가 적재되는 메모리는 순간적이기 때문에 영구적으로 보관하기 위해 직렬화를 사용합니다.
- 직렬화
자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를 '직렬화' 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.

- serialVersionUID를 선언해야 하는 이유
자바가상기계 (JVM)은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당합니다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수도 있습니다. 이런 문제를 해결하기 위해 SerialVerionUID를 사용합니다.
간단명료하게 serialVersionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도입니다.
만약 직렬화할 때 사용한 serialVersionUID의 값과 역직렬화 하기 위해 사용했던 serialVersionUID값이 다르다면 InvalidClassException이 발생할 수 있습니다.

– 제너릭이란 무엇인가요
클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것을 말합니다.

– 리플렉션이란 무엇인가요
리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.
- 리플렉션이란 무엇인가요
리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.


JVM(Java Virtual Machine)

Thread(동시성)
Thread(프로세스내에서 자원을 가지고 처리하는 "일꾼") vs Process(실행중인 프로그램 = Thread들의 "작업영역")
Thread(쓰레드) - 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다
Process(프로세스) - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)
Thread 장점
- 빠른 프로세스 생성
- 적은 메모리 사용
- 쉬운 정보 공유
Thread 단점
- 교착상태에 빠질 수 있다.
* 교착상태 - 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.
Thread와 Process 차이
여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 '실행중인 프로그램'이라는 뜻으로 쓰인다. 
이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.

MultiThread
Variable(변수)

Java Memory
	1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 할당되는 메모리 영역
	2. 스택(Stack) : 지역변수, 메서드 등이 LIFO(Last In First Out) 방식으로 할당되는 메모리 영역
	3. 힙(Heap) : new 연산자를 통해 생성된 객체들이 동적할당되는 메모리 영역. GC에 의해 관리되는 메모리 영역

GC(Garbage Collection)
	시스템에서 더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 
	시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.

Overloading vs Overriding
- 같은 이름의 메소드를 여러개 정의하는 것
- 매개변수의 타입이 다르거나 개수가 달라야 한다.
* return type과 접근 제어자는 영향을 주지 않음.
- 상속에서 나온 개념
- 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의

접근제한자(public > protected > default > private)
public - 접근 제한이 없다.(같은 프로젝트 내에 어디서든 사용가능)
protected - 같은 패키지 내, 다른 패키지에서 상속받아 자손클래스에서 접근 가능 
default - 같은 패키지 내에서만 접근 가능
private - 같은 클래스 내에서만 접근 가능

Generic : 클래스 내부에서 사용할 데이터의 타입을 인스턴스(객체) 생성시 결정짓는 방식
형변환을 할 필요없고, 타입 에러가 발생할 확률이 없어진다. 
타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다. 

컬렉션(collection) 클래스에서 제네릭을 사용하는 이유를 설명하시오.
컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함 될 수 있도록 컬렉션을 제한합니다. 
컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와줍니다.

pojo란 무엇인가
Plain Old Java Object. 간단히 포조 라는 말 그대로 해석하며 ㄴ오래된 방식의 자바 오브젝트로서 J2EE등의 중량 프레임워크들을 사용하면서 해당 프레임워크에 종석된 무거운 객체를 만들게 된 것에 반발하여 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 지칭하는 말로 사용되었다.

박싱과 언박싱에 대해서 설명해 보세요.
원시형 -> Wrapper Class로 변환 박싱
Wrapper Class -> 원시형으로 변환 언박싱
여기에 명시적, 묵시적으로 변하는 것을 설명하면 좋을 것 같음.

'데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오
데드락이란, 둘 이상의 쓰레드가 lock 을 획득하기 위해 기다리는데, 이 lock 을 잡고 있는 쓰레드도 똑같이 다른 lock 을 기다리며 서로 블록 상태에 놓이는 것을 말한다. 데드락은 다수의 쓰레드가 같은 lock 을, 동시에, 다른 명령에 의해, 획득하려 할 때 발생할 수 있다.
- 자원 유형에 따라 우선 순위를 선정하여 자원을 선점하게 한다.
- 공유 불가능한 즉 상호 배제의 조건을 제거한다.

상속과 합성(컴포지션)의 차이에 대해서 설명해 주세요.  
	상속은 is a 관계 
	컴포지션은 개체들 간에 has a 관계이다. 
	상속은 클래스를 확장하여 부모 클래스에서 속성 및 동작을 상속하는 기능입니다. 
	자동차는 자동차다.
	class Engine{}
	abstract class Automobile{}
	class car extends Automobile{
		private Engine engine;
	}
	합성은 클래스가 구성원 데이터로 다른 클래스의 객체를 포함 할 수있는 능력입니다. 
	자동차는 엔진이 포함되어 있다.

Call by Reference - 매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우
Call by Value - 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

Static의 의미 
- 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
- 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)

Primitive type과 Reference type
	- Primitive type - 변수에 값 자체를 저장 
	정수형 byte, short, int, long
	실수형 float, double
	문자형 char
	논리형 boolean
	* Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.
	예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)
	
	- Reference type - 메모리상에 객체가 있는 위치를 저장
	종류 - Class, Interface, Array 등

Wrapper Class
	Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스

<Object-Oriented Programming(OOP)> => java.txt 확인
- VM(Virtual Machine) : 모든 OS에서 Java 구동 가능
- GC(Garbage Collection) : 개발자 대신 메모리(Heap 영역)를 관리. 메모리 재사용
메모리
- 클래스(Class) : static 변수, 전역변수, 코드에 사용되는 Class 정보
- 스택(Stack) : 지역변수, 함수(매서드) LIFO 먼저들어온게 젤 마지막에 사용됨.
- 힙(Heap) : new 연산자로 동적할당된 객체들을 저장 // 가비지 컬렉션에 의해 메모리 관리됨.

- OOP(Object-Oriented Programming) : 객체 지향 프로그래밍(캡슐화, 상속, 다형성, 추상화(=인터페이스)) // 상속을 통한 중복제거, 캡슐화를 통한 정보 은닉화, 오버로딩&오버라이딩, 추상화&인터페이스를 통한 개발 집중 등등
- 메서드 : 반복작업을 메서드화

- Class : 변수 + 메서드 // 아직 메모리에 할당되지 않은 상태(판)
- Object : Class 기반으로 객체 생성 // Class에 정의 된 정보로 메모리에 할당(판에서 찍어낸 물건)

캡상추다
- 캡슐화 : 잘못된 사용으로 인해 객체가 손상되지 않도록 객체의 필드와 메소드를 하나로 묶고, 실제 구현내용을 외부에 감춘다. public private 접근 제한자 적용. getter setter로 접근 가능
- 상속 : 부모 클래스의 기능을 그대로 사용가능한 자식 클래스 생성 가능 // 다중 상속은 불가능
	- 이유1 : 검증된 클래스를 상속하여 빠르게 개발 가능
	- 이유2 : 다양한 객체를 하나로 통일 가능
- 추상화(abstract) : 껍데기 클래스. 꼭 부모메서드를 재정의(Override)하여 사용해야한다.	// 일반상속과 큰 차이 없다. 정답도 없다. 자식클래스에서 재정의 필요하다면 추상클래스 사용. 그렇지 않으면 일반클래스 상속 사용.
- 다형성 : 인터페이스를 이용하여 여러개의 껍데기를 만들고 껍데기의 기능은 따로 구현. 하나의 본체에 여러개의 껍데기를 적용하여 활용가능
	- Override : 상속받은 메서드를 재정의하여 사용
	- Overload : 클래스내에 메서드 이름은 같고 입력 매개변수 정보(개수, 타입)는 다르게 선언 가능


<Spring Framework>
– 스프링이 뭔가요
자바언어를 기반으로 다양한 애플리케이션을 개발하기 위한 경량급 프레임워크입니다. 경량급이란 말은 스프링자체가 아주 가볍거나 작은 규모의 코드로 이뤄졌다는 것이 아니라 불필요하게 무겁지 않다라는 의미입니다. 그리고 개발 중에 테스트가 쉽다는 특징이 있습니다.

– 프레임워크란 무엇인가요
소프트웨어 제작을 편리하게 할 수 있도록 미리 뼈대를 이루는 클래스와 인터페이스를 제작하여 이것을 모아둔 것입니다. 프레임워크를 사용하게 되면 개발 생산성이 증가하며 품질이 향상되고 유지보수가 편리하다는 장점이 있습니다. 반면 익숙해지는데 시간이 오래 걸리며 유연성이 부족하게 됩니다.

– MVC패턴이란 무엇인가요
애플리케이션은 크게 model, view, controller 세 영역으로 구분하여 영역 간의 결합도를 최소화한 논리적인 패턴입니다. 가장 큰 특징이며 장점은 비즈니스로직과 프리젠테이션로직이 분리 된다는 것입니다. 그로 인해 디자이너와 개발자의 영역이 분리 됨 으로써 작업의 분업화를 할 수 있습니다. 또한 유지보수에도 용이합니다.

– DAO란 무엇입니까
데이터 접근을 목적으로 하는 객체입니다.

– AOP란 무엇인가요
Aspect Oriented Programing의 약자로 다양한 곳에서 자주 사용되는 공통관심 요소를 단일 기능으로 뽑아내서 코드의 중복을 줄이고 관리의 효율성을 높이기 위해 사용합니다.

– Spring DI란 무엇인가요
Dependency Injection의 약자로 의존성을 주입하는 것을 말합니다. 설정 파일을 통해 객체간의 의존관계를 설정함으로서 객체는 의존하고 있는 객체를 생성하거나 검색 할 필요 없습니다. 그로 인해 코드관리가 편리해집니다.

5. Spring framework?
	a. 경량 컨테이너로서 자바 객체를 직접 관리.
	   각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
	b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.
	   일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 
	   존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.
	c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.
	   컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
	d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원
	   각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
	e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원
	   따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.
	f. 스프링은 영속성과 관련된 다양한 서비스를 지원
	   iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.
	g. 스프링은 확장성이 높음.
	   스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 
	   이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.
Framework : 개발할 때 설계 기본이 되는 뼈대나 구조 / 환경 (문제 영역을 해결한 재사용, 확장 가능한 라이브러리.)
MODEL 1 - REQUEST 요청에 대한 처리, 비지니스 로직 핸들링이 모두 JSP단에서 처리됨
MVC MODEL2 - MVC 구조를 웹에 적용하여 개발하는 방식
- 추가설명
자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)
자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크
자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구
자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할
스프링 특징 간단히
- 크기와 부하의 측면에서 경량.
- 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모
- 관점지향 프로그래밍(AOP)을 위한 풍부한 지원
- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음
- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음


6. Spring MVC 구조의 처리 과정
1) DispactherServlet: 모든 requeset를 받는 관문이다. request를 실제로 처리할 controller에게 전달하고 그 결과값을 받아서
view에게 전달하여 적절한 응답을 생성할 수 있도록 흐름을 제어한다.
2) Handler Mapping: request url을 각각 어떤 controller가 실제로 처리할 것인지 찾아주는 역할을 한다.
3) controller - request를 처리한 후 그 결과를 다시 DispactherServlet에게 돌려준다.
4) ModelAndView: controller 처리 결과와 그 결과를 보여줄 view에 관한 정보를 담고 있는 객체이다
5) viewResolver: view 관련 정보를 갖고 실제 view를 찾아주는 역할을 한다.
6) view : controller가 처리한 결과값을 보여줄 view를 생성한다.

DI(Dependency Injection) 
- 스프링 컨테이너가 지원하는 핵심 개념 중 하나
- 설정 파일을 통해서 객체간의 의존관계를 설정
- 객체 사이의 의존관계를 객체 자신이 아닌 외부의 조립기가 수행
- 각 클래스 사이에 필요로 하는 의존관계를 Bean설정 정보 바탕으로 컨테이너가 자동으로 연결
- 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없음 -> 코드관리가 쉬워짐
DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.
DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 
Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.
설정 파일을 통해 객체간의 의존관계를 설정함으로써 외부 Assembler가 객체간의 의존 관계를 정의하게 되며, 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없어지므로 코드의 관리가 쉬워진다.

IOC
인스턴스 생성의 제어를 개발자 본인이 아닌 다른 누군가에게 반환해 준다는 개념으로 여기서 말하는 다른 누군가는 Servlet과 같은 bean을 관리해주는 컨테이너이다.
즉 IOC란 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해준 다는 것이다.

AOP(Aspect Oriented Programming)
- 공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해 줌
- 각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보다는 Aspect를 이용하여 핵심 로직을 구현한 각 클래스에 공통 기능을 적용
- 간단한 설정만으로 공통 기능을 여러 클래스에 적용할 수 있음
- 핵심 로직 코드의 수정없이 웹 어플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용하여 간단하게 적용
: 매 프로젝트의 주가 되는 기능은 아니지만 핵심 기능마다 늘 같이 병행 되어 실행되는 중요한 기능을 표현할 때 사용

AOP용어
1. Advice : 언제 공통 관심기능을 핵심 로직에 적용할 지를 정의
2. Joinpoint : Advice를 적용이 가능한 지점을 의미
3. Pointcut : JoinPoint의 부분 집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타냄
4. Weaving : Advice를 핵심 로직코드에 적용하는 것
5. Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 Aspect라고 함, 트랜잭션이나 보인등이 Aspect의 좋은 예
<공통 관심 사항이 삽입 될 위치가 Joinpoint/ Pointcut은 Joinpoint를 적용하기 위한 조건에 해당하는 것>

AOP와 Interceptor 비교
Interceptor
Filter 
AOP 
 실행 위치
 서블릿
서블릿 
메서드 
 실행 순서
 2
1(제일 먼저와 제일 나중) 
 3
 설정 위치
 xml or java
web.xml 
xml or java 
 실행 메서드
 preHandler
postHandler
afterCompletion
 init
dofilter
destory
pointcut으로 @after, @before, @around 등 위치를 지정하여 자유롭게 메서드 생성 가능 
실행되는 메서드를 기준으로 설명하면, 서버를 실행시켜 서블릿이 올라오는 동안 init이 실행
-> 그 후 dofilter가 실행 -> 컨트롤러에 들어가기 전에 preHandler 실행 -> aop가 실행된 후 나오면서 
-> postHandler -> after Completion, dofilter 순서대로 실행 -> 서블릿 종료시 destory가 실행
*AOP의 경우에는 Interceptor나 Filter와 달리 메서드 전후의 지점을 자유롭게 설정 가능하고, interceptor와 filter가 주소로만 걸러낼 대상을 구분 할 수 없는 것에 비해서 AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있는 장점이 있음.

Filter vs Interceptor
Filter와 Interceptor는 실행되는 시점이 다르다. 
Filter는 Web Application에 등록을 하고, Interceptor는 Spring의 Context에 등록을 한다.
컨트롤러에 들어가기 전에 작업을 처리하기 위해 사용할 수 있다는 공통점이 있지만 호출되는 시점이 다르다.
1. Filter는 Dispatcher servlet의 앞단에서 정보를 처리하고, Interceptor는 Dispatcher servlet에서 Handler(Controller)로 가기 전에 정보를 처리한다.
2. 또한 필터는 J2EE 표준 스펙에 정의 되어 있는 기능이며, 인터셉터의 경우는 Spring Framework에서 자체적으로 제공하는 기능이라고 한다.
정확히 어떤 상황에 어떤 기능을 사용해야 하는가에 대해서는 갑론을박이 많지만, 인코딩이나 보안 관련 처리와 같은 web app의 전역적으로 처리해야 하는 로직은 필터로 구현하고 클라이언트에서 들어오는 디테일한 처리(인증, 권한 등)에 대해서는 주로 인터셉터에서 처리하는듯 하다

DAO
Data Access Object의 약자로 간단히 Database의 data에 접근을 위한 객체입니다. Database에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용을 합니다
DAO(Data Access Object)는 DB를 사용해 데이터를 조화하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

DTO
DTO(Data Transfer Object)는 VO(Value Object)로 바꿔 말할 수 있는데 계층간 데이터 교환을 위한 자바빈즈를 말합니다.여기서 말하는 계층간의 Controller, View, Business Layer, Persistent Layer를 말하며 각 계층간 데이터 교환을 위한 객체를 DTO 또는 VO라고 부릅니다. 그런데 VO는 DTO와 동일한 개념이지만 read only 속성을 가짐

Spring MVC Annotation
- 메타 데이터를 XML에 설정하는 것이 아니라 소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메서드의 선언부에 적용 할 수 있는 특정 기능이 부여된 표현법
- 프레임워크들이 활성화 되고 어플리케이션 규모가 커질수록 XML 환경 설정은 복잡해지는데, 이러한 어려움을 개선시키기 위하여 자바 파일에 어노테이션을 적용해서 코드를 작성함으로써 개발자가 설정 파일에 작업하게 될 때 발생시키는 오류의 발생 빈도를 낮춰주기도 함
- 어노테이션을 사용하면 소스 코드에 메타데이터를 보관할 수 있으며, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용하여 코드의 가독성을 높일 수 있음

기본적인 5가지 어노테이션
1. @Controller
 - 특정 클래스를 Controller로 등록하는 어노테이션
 - dispacter-servlet.xml에서 <bean>태그로 정의한 것과 동일한 효과를 나타냄
 - DefaultAnnotationHandlerMapping을 통해 컨트롤러로 등록되어 사용됨
2. @RequestMapping
 - 컨트롤러로 등록된 클래스내에 특정 메서드를 요청되는 URL과 매칭시키는 어노테이션
3. @Autowired
 - Spring에서 자동으로 Dependency Injection을 하기 위한 어노테이션
4. @Service
 - @Service로 정의한 클래스는 비지니스로직 처리 Service로 등록이 됨(Impl에서 사용 @Service("boardDao"))
5. @Repository
 - Dao로 등록
프로젝트에서 @Service가 아닌 @Component 사용했음
- @Component는 스프링이 관리하는 모든 컴포넌트에 대한 제너릭 스트레오 타입/ 일반적인 용도의 컴포넌트들을 표시하는 기분 스트레오 타입/ 스프링에 의해 자동으로 탐지됨
- @Repository, @Service, @Controller는 스프링 프레임워크의 차기 릴리즈버전에서 추가적인 의미가 생길 가능성이 있다. 그래서 서비스 계층에 @Component나 @Service중에서 어느것을 사용할지 선택해야 한다면 @Service가 명확하게 더 나은 선택이다.

Spring JDBC
- 데이터베이스 테이블과 자바 객체 사이의 단순한 매핑을 비교적 간단한 설정을 통해 처리
- 지금까지 배웠던 JDBC는 하나의 DAO 클래스에도 어떤 로직을 구현하는가에 따라 여러가지의 SQL문이 존재하게 되고 SQL문 하나를 실행하는데도 Connection, PrepareStatement, ResultSet 등 여러개의 클래스를 생성하고 Exception 처리도 해야 하는 번거로움이 있었다. Spring에서는 JDBC를 비롯해 ORM 프레임워크를 직접적으로 지원하고 있기 때문에 약간의 노력만 하면 간단하게 연동할 수 있음

Spring DAO에서 대신 해주는 것들
  - Connection 파라미터 정의
  - Connection 열기
  - Satement 생성
  - SQL 문에 parapm 데이터 세팅
  - Statement 실행
  - result 값을 반복하기 위한 loop 설정
  - 반복에 대한 작업 결과값 추출
  - 예외처리
  - 트랜잭션 처리
  - Connection 담기
  * 그냥 지가 다해준다고 생각하면 편함

MyBatis
-객체, 데이터베이스, 매퍼 자체를 독립적으로 작성하고 DTO에 해당하는 부분과 SQL실행결과를 SQL문등에 매핑해서 사용할 수 있도록 지원
-스프링이나 JDBC를 통해 작업하던 dao에 관련된 작업은 모두 sql문이 자바 소스상에 위치했었으나 이제 sql문은 설정파일로 관리한다.
-설정파일로 분리되면 변경되거나 했을때 설정파일만 건드리면 되므로 유지보수에 좋다. 또한, 매개변수나 리턴타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업한다

MVC
- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,
- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

MVC 구성요소
Model - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.
View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)
Controller - Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용.

- MVC1과 MVC2 패턴의 차이를 설명해 주세요.
Model1(JSP, 자바빈 또는 서비스 클래스)
JSP페이지 내에 로직 처리를 하기 위해 자바 코드가 출력을 위한 코드와 함께 삽입된다. JSP페이지는 요청이 오면 직접 자바빈이나 클래스를 이용하여 작업을 처리하고 처리한 정보를 클라이언트에 출력한다.
장점 : 구조가 단순하다
단점 : 출력을 위한 HTML 코드와 로직 처리를 위한 Java코드가 삽입되어 복잡하고, 유지보수가 어려워진다.
Model2(서플릿, JSP, 자바빈 혹은 서비스 클래스)
모든 처리를 JSP가 담당하는 것이아니라 JSP 페이지와 서블릿 그리고 로직을 위한 클래스가 나뉘어 클라이언트의 요청을 처리한다.
클라이언트에서 요청이 오면 처리할 모델을 클래스 또는 자바 빈이 담당하고 요청결과는 뷰(JSP), 흐름 제어는 Controller인 서블릿이 담당한다.
MVC 패턴이란 Model2 구조를 도입한 구조이며 같은 형태를 가지고 있다.
Model - 서비스 클래스 OR 자바빈
비지니스 로직을 처리하기 위한 모든 것들이 모델에 속한다 EX) 게시판 글쓰기, 가입, 로그인 등 로직을 수행하고 수행 결과를 컨트롤러에 반환한다.
View - JSP
클라이언트에서 출력하는 화면을 말한다.
Controller - 서블릿
MVC 패턴의 모든 흐름제어를 맡는다.
브라우저에서 요청이 들어오면 어떤 요청인지를 분석하고 이 요청을 처리하기 위한 모델을 사용하여 처리한다. 사용한 모델로부터 처리결과를 받으면 추가로 처리하거나 가공해야할 정보가 있다면 처리 후 request 또는 Session 객체에 저장하고 뷰를 선택하여 클라이언트에 출력한다.
장점 : M V C 모델이 나누어 지기 때문에 코드를 분리하여 쉽게 유지보수가용이하다.
뷰, 로직 처리에 대한 분업이 용이하다.
단점 : 구조가 복잡하여 습득이 어렵고 작업량이 많다.

1. 스프링이란? : Java언어를 기반으로, 동적인 웹 사이트 개발을 위한 여러 가지 서비스 제공. 
	- Spring Container : 설정정보(XML or @)를 참고로 해서 어플리케이션을 구성하는 오브젝트를 생성하고 관리(=객체의 생명주기 관리)한다.
	- IoC(Inversion of Control) = 컨테이너 : 제어의 역전. 오브젝트의 제어 권한을 Spring Container에게 위임하는 방식. 개발자는 Class만 정의하고 사용. 생성, 파괴등 생명주기는 Spring Container가 알아서 처리.
	- DI(Dependency Injection) : 의존성 주입. 설정정보(XML or @) 기반으로 오브젝트간의 의존성 주입. A객체에서 사용되는 B, C 객체를 정의. A객체 생성시 B, C객체를 같이 생성해서 엮어줌. IoC 컨테이너가 알아서 연결해줌.
	- 추상화(Abstract(추상, 일반 메서드 다 사용가능) vs Interface(오로지 추상메서드랑 상수만 사용, 다중상속가능, 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있음.)) : 하위 시스템의 공통기능을 뽑아내서 분리하여 껍데기, 내용(실제 기능 구현) 구조로 개발 // 재사용성 증가, 현재 개발중인 부분에 집중
	- AOP(Aspect Oriented Programming) : 관점 지향 프로그래밍. 핵심 비지니스 로직과 공통 모듈로 구분. 핵심 비지니스 로직을 건드리지 않고 공통된 기능을 모듈화하여 관리하고 적용. Java의 상속기능만 사용했을 시, 발생하는 문제 및 한계점을 극복하기 위함. (= 부모 자식 관계 상관없이 여러 객체에서 사용해야만 하는 공통적인 기능이 있을 경우, AOP 적용)
	=> 로그, 트랜잭션, 자원해제, 성능테스트 메서드

AOP(Aspect Oriented Programming) : 공통기능을 모든 모듈에 적용하기 위함. ex> SSO, Log, Check, 특정 메소드 실행&종료시간(=경과시간) 체크 등등에 활용
	- Aspect : 공통 기능 (advice + joinpoint + pointcut)
	- Advice : Aspect의 기능 자체 (종류 : before(메소드 실행 전) // around(메소드 전/후, exception 발생시) // after-returning(정상 메소드 실행후) // after-throwing(메소드 실행중 exception 발생시) // after(메소드 실행후 무조건 발생) **동작방식
	- Joinpoint : Advice를 적용해야 되는 부분(ex. 필드, 메소드)(스프링에서는 메소드만 해당) **동작방식이 적용된 부분
	- Pointcut : Joinpoint의 부분으로 실제로 Advice가 적용된 부분 **적용위치
	- Weaving : Advice를 핵심 기능에 적용하는 행위 **적용행위
	
	AOP 구현방법 : 호출부(Client) -> Proxy(대행) -> Target(핵심기능)
		1. XML 이용
			1. 의존 설정(pom.xml) : org-aspectj
			2. xml 설정 : <bean/> <aop:config></aop:config>
			3. 공통 기능 클래스 생성 필요.
			
			*. AOP 라이브러리를 받아서 사용. 공통 기능 클래스 생성 -> 빈 생성 -> AOP Config -> 어떤 공통 기능을 어떤 패키지 범위에 있는 메소드들에 적용한다고 설정 // 특정기능 실행전, 실행후 등 시점 선택가능
		2. @Aspect 이용 
			1. 의존 설정(pom.xml) : org-aspectj
			2. @Aspect 를 이용한 클래스 제작
			3. xml에 <aop:aspectj-autoproxy /> 설정  -> 이걸해야 @Aspect 인식하여 동작 가능
			
		*. aspectj Pointcut 표현식
			execution() // within() // bean()


<MVC : Model View Controller>
데이터 혹은 데이터를 처리하는 영역 / 결과 화면(웹페이지)을 만드는 영역 / 클라이언트의 요청(Request)를 처리하는 영역(= 모델과 뷰사이의 중간연결)

<Spring 요청처리 과정>
1. 웹 Application 실행되면 Tomcat(WAS)에 의해 web.xml이 로딩
2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성
3. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.
4. 생성된 ContextLoaderListener는 root-context.xml을 로딩
5. Client Request
6. DispatcherServlet(Servlet)이 생성. FrontController 역할을 수행한다.
7. HandlerMapping, ViewResolver 같은 PageContoller에서 요청을 분석하여 어떤 응답을 할지 결정
8. 7번의 응답 결정 과정에서 DispatcherServlet은 servlet-context.xml을 로딩 -> @Controller 찾기 -> @RequestMapping을 통해 요청을 처리할 메서드 결정 -> Service에 요청 -> 비즈니스 처리 -> DAO에서 DB처리 -> 결과값 VO에 담아서 리턴 -> VO + View 결과물을 DispatcherServlet에게 전달
9. Client Response

*. Filter 서블릿단에서 제일 먼저, 제일 나중에 실행 // web.xml에 정의됨(init, dofilter, destory)
*. Interceptor 서블릿단에서 실행, 2번째로 실행 // xml or java 소스로 설정(preHandler, postHandler, afterCompletion)
*. AOP 메서드단에서 실행, 3번째로 실행 // xml or java 소스로 설정(pointcut으로 @after, @before, @around 등 위치를 지정하여 자유롭게 메서드 생성가능)

<Spring Cloud Data Flow>
1. 지속적인 배포가 중요한 시점.
2. Conway's Law : 개발자 팀의 형태에 따라 서비스의 형태가 결정된다.
3. 여러 개발자들이 모여서 작업 -> 하나의 통 서비스
4. 4~7명 단위로 개발자가 팀으로 운영됨 -> 기능 별로 쪼개진 마이크로서비스 // 요청을 구분짓는 개념이 필요함(API Gateway), 중간단계의 통신 개념이 필요함(API, RabbitMQ)
5. 지속적으로 배포(자동으로)한 결과에 대한 DB 통계 결과를 빠르게 확인하여 지속적인 좋은 서비스 제공.
6. Data를 처리하는 Flow를 설정값이 정의
7. MicroService들이 6번의 Flow를 따라 HTTP 요청을 처리한다. MicroService들은 RabbitMQ 또는 kafka 같은 도구를 통해 데이터를 주고 받아 처리한다.
ex> 데이터 처리결과를 복제된 DB에 쌓기 -> 분석 -> 결과통계 등 머신러닝처리

<자료구조 & 알고리즘>
1. Comparable : int, String, Date 같은 타입의 객체에 기본적으로 적용된 비교 정렬 인터페이스. 해당 객체를 상속받아 compareTo 메서드를 재정의하여 사용 가능. 기본적으로 작은수->큰수, a->z, ㄱ->ㅎ 오름차순 정렬

2. Comparator : Comparator 객체를 생성후 compare 메서드를 재정의하여 Collections.sort(targetCollection, comparator)의 매개변수로 활용하여 사용자 임의의 정렬가능

3. Arrays와 Collections에 대한 API 활용(.sort .asList 등)

4. 빅오, 시간-공간복잡도
	- O(1) : Push, Pop on Stack // Access hash table
			nO(1) = O(1)
			2*O(1) = 10*O(1) = O(1) -- 상수의 곱은 무시
	- O(log n) : Binary Search Tree Access // Search, Insertion, Deletion
	- O(n) : Loop // Traverse Tree // Traverse Linked List
	- O(nlog n) : Quick Sort, Merge Sort, Heap Sort
	- O(n^2) : 이중 Loop // Insertion Sort // Bubble Sort // Selection Sort
5. 버블정렬
	- 배열을 순회하면서 인접한 인자와 크기를 비교하여 스왑하는 행위를 반복하는 정렬
	- 구현은 쉽지만 성능이 매우 비효율적이다.
	- Worst-Performance O(n^2), Best-Performance O(n) 이미 정렬이 되어 있을때, SpaceComplexity O(1)
	
6. 삽입정렬
	- 정렬대상 배열에서 인자를 순차적으로 신규배열에 삽입. 신규배열에 삽일할땐 순차적으로 순회하면서 비교하여 삽입위치를 정한다.
	- 구현은 쉽지만 성능이 매우 비효율적이다. 버블정렬보다 저장공간도 2배 필요하다. 하지만 삽입이 결정되면 남은 리스트를 순서대로 확인하는 불필요한 작업이 필요 없어서 조금 낫다.
	- Worst case Performance : O(n^2) // Best case Performance : O(n) 거꾸로 정렬이 되어 있을때

7. 퀵정렬
	- 재귀적 알고리즘
	- 공간복잡도 효율적임. 본인 데이터만 사용 // 임의의 Pivot(기준점)을 정한다. 해당 Pivot 보다 작으면 left side, 크면 right side로 삽입한다. 재귀형태로 left부분을 정렬하여 최종 리스트에 삽입. pivot 삽입. right부분을 정렬하여 최종 리스트에 삽입하여 정렬을 끝낸다. 
	- Performance : O(nlog n), Worst case(이미 정렬된걸 실행할때 최악.) O(n^2) // space complexity : O(n)
	
8. 병합정렬
	- 재귀적 알고리즘
	- 리스트의 아이템이 1개 남을때까지 반씩 쪼개서 2개의 리스트를 비교하면서 병합 // 2개의 리스트를 각각 index 0번부터 서로 비교하여 작은 수를 병합리스트에 삽입하고 index를 증가한다. 이를 반복하는 한다. 2개의 리스트중에서 하나라도 index값이 size값과 같아지면 반복을 종료하고 각각의 리스트에 남아있는 값들을 차례대로 병합리스트에 삽입하여 병합을 마무리한다.
	- Performance : O(nlog n) // space complexity : O(n)
	
9. 이진검색
	- 정렬된 리스트를 이진트리 검색하면 매우 효율적이다. 정렬된 리스트의 중간값 선정. 찾고자 하는 값과 중간값 비교하여 lower, higher 선택. 선택된 영역에서 중간값을 선정하여 찾고자 하는 값과 비교를 반복하여 중간값과 찾는 값이 같아질때까지 재귀한다.
	- 성능 : O(log2 n) 아주 빠름. == 백만개중 하나를 찾을때 20번 미만의 비교로도 찾을 수 있다.

1. 일반Array
@Test
public void arrayDefinitions(){
	final int[] integers = new int[3];	// 배열은 Size를 선언하여 초기화한다.
	final boolean[] bools = {false, true, false, true};
	final String[] strings = new String[]{"one", "two"};
	
	final Random r = new Random();
	final String[] randomArrayLength = new String[r.nextInt(100)];
}
	- 고정 Size // 인덱스를 이용한 직접 접근 가능 = 랜덤 접근
	- 크기 삽입시 크기를 확장하여 신규배열을 생성하여 기존배열의 내용과 삽입내용을 신규배열에 복사한다. = System.arrayCopy()
	- 크기변경 삽입&삭제 = 배열신규 생성 및 복사연산에 대한 시간과 메모리 소요
2. ArrayList
	- 초기에 크기 지정 가능. 지정하지 않으면 기본값 10
	- 삭제하면 배열의 크기는 줄어들지 않아 공간을 낭비할 수도 있다.
	- 랜덤접근이 필요할때, 리스트 크기가 고정되고 클때 활용하면 좋다.
3. LinkedList
	- 값, 다음원소를 가르키는 next타입 존재.
	- 검색시 항상 시작점(head)부터 next.next.... 를 재귀로 반복하여 찾아간다.
	- 삽입&삭제가 단순하고 빠르다. next의 주소만 바꿔주면 되어서 빠르다. 변경이 많이 일어나는 상황이라면 LinkedList를 쓰는것이 적합하다.
	- Stack처럼 변경이 많이 일어나는 자료구조는 LinkedList활용하면 좋다.
	- next, prev 모두 존재하는 LinkedList인 경우엔 순방향, 역방향 검색 모두 가능.
	- 삽입/삭제가 많다면, 리스트 크기가 작아지면 메모리 용량 역시 작아진다.

4. Stack
	- LIFO 후입선출.
	- push, pop
	- 수식연산, 함수실행순서
5. Queue
	- FIFO 선입선출.
	- add, remove, peek(가장 오래된 원소를 반환하지만 삭제하진 않는다.)
- STACK
	- LIFO(Last In First Out)의 후입선출 구조
	- push();를 이용한 데이터 입력, pop();을 이용한 데이터 출력
	- 예) 시스템 스택 : 함수의 호출과 복귀 순서는 스택의 구조를 응용하여 관리
	- 역순 문자열 만들기, 수식의 괄호 검사, 수식의 후위 표기법 변환

- QUEUE
	- FIFO(First In First Out)의 선입선출 구조
	- enQueue();를 이용한 데이터 입력, deQueue();를 이용한 데이터 출력
	- 예) 우선순위가 같은 작업 예약(인쇄 대기열), 선입선출이 필요한 대기열(티켓 카운터)
	* Linear Queue(선형큐)는 메모리 재사용이 불가능 이러한 문제점을 보완하여 Circular Queue(원형 큐)가 나옴

	
6. Deque
	- Queue의 확장
	- add, remove를 양끝에서 가능하도록 구현.
	
7. 이진트리(Binary Tree)
	- Root 기준으로 크기가 작으면 left Children, 크면 right Children에 삽입
8. 이진검색트리(Binary Search Tree)
	- Root부터 시작해서 크기가 작으면 left로 크면 right로 재귀형태로 찾아들어간다.
9. AVL Tree
	- 이진트리에서 1,2,3,4,5를 순서대로 삽입하면 한쪽방향으로만 깊이가 깊어지는 형태로 만들어져서 검색&삽입에 성능 문제가 생긴다.
	- 이를 극복하기위해 고안된 AVL Tree
	- 어떤 노드든 모든 자식의 깊이 차이가 1을 넘지 않도록 만든다.
	- 삽입&삭제후 왼쪽과 오른쪽 부분의 균형이 맞는지 확인. 균형이 맞지 않으면 재배열
	- O(log n)
10. 이진 힙(Binary Heap)
	- 자식 노드가 부모보다 큰 속성을 갖도록 균형이 잡힌 트리 = Root에 가장 작은 원소가 위치한다.
	- 어디다 쓰고 뭐가 이점이지?
11. n-진 트리
	- ??
	
10. HashMap
	- Key-Value // O(1) 성능
	- 가장 일반적인 Map
	- hashcode 값을 생성하여 Key-Value 쌍이 어디에 있는지 확인하는데 사용한다.
	- hashcode 값으로 해시테이블 인덱스를 정의한다.
	- 해당 인덱스가 중복될 가능성이 있어서 처리방법도 고려해야한다.
	- 이렇듯 Map의 크기가 커지면 재할당 작업이 발생하여 적당한 크기로 테이블을 초기화해야한다.
	- HashCode 설명???
11. TreeMap
	- Map의 데이터 저장방식을 Tree방식으로 이용한다.
	- hashcode 메서드를 전혀 사용하지 않는다.
	- 이진트리형식이라 O(log n) 성능을 발휘한다.
	- HashMap vs TreeMap : TreeMap은 전체 반복 순회시 키의 순서(1~n 정렬된 순서)가 보존. HashMap은 순서가 보존되지 않는다.
12. LinkedHashMap
	- 기본적으로 HashMap과 동일한 형태로 동작한다. // O(1) 성능
	- Linked 성격을 띄고 있어서 삽입한 순서대로 순회된다.
13. ConcurrentHashMap
	- 많은 스레드에서 공유하고자 할때 사용한다.
	- Map에 값을 쓰는 도중이라도 값을 읽어서 반환할 수 있도록 설계되어 있음.
	- 값을 쓰는 동안에는 테이블의 지정된 Row만 잠기고 Map의 나머지는 읽기 가능한 상태로 남겨둔다.

14. HashSet
	- 중복을 허용하지 않는 순서 없는 객체들의 모음
	- 값을 Map Key-Value 형태로 저장한다.
15. TreeSet
16. LinkedHashSet
17. ConcurrentHashSet은 없다. : Collection.newSetFormMap()을 이용하면 ConcurrentHashMap와 유사한 Set객체 활용이 가능


<Design Pattern>
Singleton Design Patter(싱글톤 디자인 패턴, 싱글톤 패턴)
- 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

<Database>
– ORM이란 무엇인가요
ORM이란 객체와 관계형 데이터베이스을 중간에서 매핑하는 것입니다. SQL만 잘 작성하더라도 충분히 개발 할 수 있지만 SQL를 직접 작성하는 번거로운 작업을 줄여주고, 직접 계산하고 연산하는 부분을 지양해야 하기 때문에 이용됩니다.

– 정규화란 무엇인가요
정규화란 테이블의 데이터들간의 종속성, 중복성 등으로 인해 예기치 못한 오류를 제거 하는 과정이라 할 수 있습니다. 정규화를 진행했을 때 장점은 DB의 일관성을 향상시킬수 있습니다. 또한 DB의 논리적 구조를 견고하게 만들 수 있습니다. 하지만 테이블의 숫자가 늘어나고 결국 join 연산의 비용이 증가 하는 단점을 가질 수 있습니다.

– 무결성 제약조건이란 무엇인가요
데이터의 정확성과 일관성을 보장하기 위해 테이블 생성 시에 각 칼럼에 대해 정의하는 규칙을 의미합니다. 그로 인해 프로그래밍 과정을 줄일 수 있고, 데이터 오류 발생 가능성을 줄여줍니다.

– ERD란 무엇인가요
ERD란 계략적으로 데이터 및 데이터들의 관계를 표현한 도식화된 그림입니다. 조직의 데이터를 이해하고, 이를 응용시스템에 이용하고자 ERD를 작성합니다.

– 컬럼에 인덱스를 생성하는게 좋은지, 생성하지 않는게 좋은지 기술하시오
상황에 따라 다르다고 할 수 있습니다. 인덱스를 생성하려는 컬럼이 분포도가 좋아 활용도가 향상되거나 수정이 빈번하지 않다면 인덱스를 생성하는 것이 좋습니다. 하지만 인덱스 컬럼이 비교되기 전에 변형이 일어난 경우나 부정형으로 조건을 기술한 경우 인덱스를 생성 하지 않는 것이 좋습니다. 지나친 인덱스 선언은 많은 오버헤드(어떤 처리를 하기 위해 들어가는 간접적인 처리시간, 메모리 등을 말한다)를 발생 시킬 수 있습니다.

– 저장 프로시저(stored procedure)란 무엇인가
저장 프로시저란 한 개 이상의 복잡한 SQL Query문들을 데이터베이스에 저장하고 필요한 경우 호출해서 사용하는 객체입니다. 저장 프로시저를 사용 하면 트래픽을 감소 시킬 수 있고, 보안이 강화되며, 코드의 재사용이 가능하며, 유지 관리에 용이합니다.

– DBMS란 무엇인가요
데이터를 적절하고 효율적인 관리의 필요성으로 인해 등장한 체계적으로 데이터를 관리하는 시스템입니다. DBMS를 사용함으로써 사용자 중심의 데이터 처리가 가능하며, 중복성 통제, 데이터의 일관성 유지 등의 장점을 가지고 있습니다. 종류로는 관계형, 객체 지향형, 객체관계형 데이터베이스가 있습니다.

– JOIN은 언제 사용합니까
저희는 데이터 무결성과 중복성, 종속성을 해결하기 위해 테이블을 정규화 시켰습니다. 그렇기 때문에 여러 테이블에서 정보를 필요로 합니다. 그 때 사용하는 것이 JOIN입니다. 당연히 JOIN을 사용하기 위해서는 테이블간의 관계가 설정 되어 있어야 하며 이를 통해 테이블간의 행을 비교 하면서 필요로 하는 정보를 가져 올 수 있습니다.

– Primary key와 Foreign key를 비교하여 설명하시오
Primary key란 테이블에서 각 Row를 유일하게 구분하는 컬럼키입니다. Foreign key는 하나의 테이블에 있는 컬럼으로는 그 의미를 표현 할 수 없는 경우, 다른 테이블의 Primary key를 참조한 값입니다.

– JDBC란 무엇인가요
JDBC란 자바에서 데이터베이스와 관련된 작업을 처리할 수 있도록 도와주는 API입니다. JDBC의 특징을 말씀드리면 DBMS에 의존하지 않습니다. 그 이유는 자바애플리케이션으로부터 사용하는 JDBC드라이버매니저와 DBMS에 의존하는 JDBC드라이버를 분리했기 때문입니다. 또한 표준적인 SQL을 실행하는 메서드를 가지고 있기 때문입니다.

6. Oracle 클러스터 인덱스와 넌 클러스터 인덱스의 차이 
클러스터드 인덱스 : 실제 DB의 데이터 파일에 정렬되어 있는 상태로 디스크에 저장이 됨. 테이블당 한개 
넌클러스터드 인덱스 : 실제 DB의 데이터 파일에 정렬되지 않는 상태로 디스크에 저장이 됨. 테이블당 여러개(249개)

7. JOIN의 종류
- 카티션 곱(Cartesian Product) 
두 개 이상의 테이블에 대해 연결 가능한 행을 모두 결합하는 조인 방법이며, WHERE 절에서 조인 조건절을 생략하거나 조인 조건을 잘못 설정하여 양쪽 테이블을 연결하여 조건에 만족하 는 행이 하나도 없는 경우에 발생 합니다. 
 예) SELECT * FROM DEPT A, EMP B 
- EQUI JOIN 
 SQL 문에서 가장 많이 사용되는 조인으로 조인 대상 테이블에서 공통 칼럼을 ‘=’ 비교를 통해 같은 값을 갖는 행에 대해서 연결하여 결과를 생성하는 조인 방법입니다. 
 예) SELECT A.name FROM DEPT A, EMP B WHERE A.code = B.code 
- NON-EQUI JOIN 
 조인 조건에서 ‘<’,’>’, BETWEEN a AND b’와 같이 ‘=’ 조건이 아닌 다른 종류의 연산자를 사용 하는 조인 방법입니다.
  예) SELECT A.name FROM DEPT A, EMP B WHERE A.code > B.code
- OUTER JOIN 
 두 개 이상의 테이블 조인 시 한쪽 테이블의 행에 대해 다른 쪽 테이블에 일치하는 행이 없더 라도 다른 쪽 테이블의 행을 NULL로 하여 행을 Return하는 것이 OUTER JOIN 입니다.연산자 로는 (+)기호를 사용합니다. 
 예) SELECT A.name FROM DEPT A, EMP B WHERE A.code = B.code(+)
- SELF JOIN 
 하나의 테이블에서 두 개의 칼럼을 연결하여 EQUI JOIN을 하는 방법

- JDBC - Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미

- Database에서 Index란?
인덱스는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다.
인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.
고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다.
데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다. 
사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다. 

- DB에서 자료를 검색하는 두 가지 방법
FTS(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법
Index Scan : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.

- inner join / outer join 차이점
- 정규화과정을 하는 이유
- insert, update, delete 쿼리작성
- 서브쿼리(GIS에서 사용하는???)

<REST // API>
- REST : 인터넷 상의 컴퓨터 시스템간 상호 운용성을 제공하는 방법 중 하나 (= 인터넷을 통해 컴퓨터 시스템간을 연결해주는 방법을 정의해놓은 네트워크 아키텍처 // 네트워크간 연동 방식 개념 // 프로토콜 x) ex> 이메일전송, 푸쉬
- 제약조건을 준수해야 RESTful 하다라고 한다.
	- 클라이언트/서버 구성, 서버는 API를 제공하고 비지니스 로직 처리와 데이터 저장을 책임. 클라이언트는 사용자인증, 상태(세션, 로그인정보)관리와 서버 리소스 요청을 책임. 상호 의존성을 줄이는 형태로 개발해야함
	- 무상태(Stateless) : REST 서버는 작업을 위한 상태정보(세션, 쿠키 등)을 관리하지 않아야 함. 병렬로 구성한 상태에서 하나가 고장나도 시스템에 영향없이 관리 및 업데이트 가능한 형태
	- 캐쉬(Cacheable) : HTTP 웹 표준으로 HTTP가 가진 캐싱 기능이 적용됨
	- 계층화(Layered system) : 서버를 다중 계층으로 구성될 수 있음. 비지니스 로직을 수행하는 API와 서버와 그 앞단에서 사용자 인증, 암호화, 로드밸렁싱 등의 계층을 추가해 구조상의 유연성 제공
	- 인터페이스 일관성(Uniform interface) : 아키텍처를 단순화하고 분리해 각 부분을 독립적으로 발전 시킬 수 있음.
- REST API : REST기반으로 서비스 API를 구현한 것. OpenAPI(누구나 사용 가능하도록 공개된 API ex>구글맵..) 마이크로 서비스로 많이 구성하여. 확장성과 재사용성을 극대화. HTTP 기반으로 구현.
- 주요 구성요소
	- 리소스 : 접근할 대상, URI를 통해 식별
	- 메소드 : 리소스에 대한 행위, 표준 HTTP 메소드에 따라 자원에 접근(생성, 조회, 수정, 삭제)
	- 메시지 : HTTP 헤더와 바디에 포함된 메시지는 메시지를 처리하기 위한 충분한 정보를 포함
	*** REST는 어떤 자원(리소스)에 어떤 행위(메소드)를 어떻게(메시지)할지 HTTP 기반으로 정해놓은 아키텍처
- 리소스(자원)
	http://api.domain.com/books/
	http://api.domain.com/books/1/
	http://api.domain.com/books/1/photo
	/(컬렉션)/(아이템)/(컬렉션)/(아이템)/.../.../
	
- 메소드(행위)
POST, GET, PUT, DELETE 생성, 조회, 수정, 삭제
URI + 메소드 = URI 정보에 대해 메소드행위를 수행한다.

- 메시지(헤더 + 바디)
JSON으로 결과 응답을 많이 하는 추세

- 응답 상태코드
200 : 정상
201 : 리소스 생성 요청 성공(POST 성공 = create 성공)
400 : 요청이 부적절함
401 : 인증되지 않은 상태에서 보호된 리소스 요청
403 : 공개되지 않은 리소스에 접근 요청(인증과 무관)
404 : 존재하지 않는 리소스 요청
406 : 지원하지 않는 미디어타입을 요청
409 : 리소스 상태에 의해 해당 요청을 수행하지 못함

<ETC>
Maven
Ant
Gradle

XML(Extensible Markup Language)
JSON

<면접>
1. 1 분(or 30 초) 자기소개
2. 5 년 후 나의 모습은 어떠한 모습인가?
3. 본인의 장단점
4. 본인이 앞으로 어떻게 노력할 것인가
5. 최악의 버그는 무엇인가?
6. 마지막으로 하고 싶은 말

1. 팀원과의 불화는 없었는가?
2. 가장 도전적이었던 부분은 어떤 부분인가?
3. 가장 재미있던 부분은 어떤 부분인가?
4. 생산성을 높이기 위해서 시도한 부분이 있는가?
5. 프로젝트가 끝나고 모자람을 느낀적 없었나? 있었다면 어떻게 그 모자람을 채웠나?

1. 이력서에 대한 완벽한 부분 추가 설명 & 경험

<면접 질의>
1.pivotal(대각선이 고정인 행렬) 3x3, 4x4를 뒤집는 로직을 짜보세요 재귀를 써야함.
2.JAVA에서 Single ton패턴을 쓰는 이유를 말해보세요.
3.10칸짜리 배열로 스레드 세이프한 Queue를 만들어 보세요.
4.동기, 비동기에 대해 설명하고 장단점을 각각 설명 해보세요.
5.DB 클러스터링과 리플리케이션의 차이점에 대해 설명해보세요.
- 클러스터링은  DB서버를 다중화 하는 것이고 리플리케이션은 서버와 데이터를 같이 다중화 하는 것
- replication은 master, slave로 구분
- clustering은 각각의 node가 동일한 정보를 사용하는데... 분배를...
6.Thread 가 3개 생성 되었을 때 t1, t2, t3의 순서가 보장 되는 코드를 짜 보세요.
7.Spring을 쓰는 이유
8.Spring에서 Single ton이란?
9.Spring DI, IoC에 대해 설명 해보세요.
- DI 의존성 주입 서비스를 통해 리소스를 제어하는데 서비스에 대한 인스턴스를...인서트 한다.
10.Java8에서 Stream을 사용한 경우 발생 할 수 있는 문제점은?
11.Java에서 가비지 컬렉터가 너무 잘 작동 했을 때 이 문제를 진단하는 방법과 해결 하는 방법은?
12.Call by value, Call by reference에 대해 설명 해보세요.
- java는 call by reference이고 대체로 콜 바이 레퍼런스이다. a = 10; b = a; 라고 하면 b는 10이 들어가는게 아니고 a의 주소가 복사가 된다. 그래서 b를 수정하면 a에도 영향을 미치는게 call by reference
- call by value 는 a = 10; b = a; 했을 때 b = 10이 된다. b를 수정해도 a에 영향을 주지 않는다.
13.Process와 Thread의 차이점
java로 따지면 process는 .jar를 실행 하는 것이고 thread는 .jar내에서 실행 하는 것.
Process대신 Thread를 쓰는 이유는 Process는 다시 띄워야 하는데 Thread는 프로그램 안에서 해결이 되기 때문.
14.JVM 구조
- Method(Static) Area
class의 구조 정보가 들어간다.
- Stack Area
Method정보, 메소드 호출 시 사용하는 지역변수 데이터 등을 저장한다. {}가 끝나는 동안 유지된다.
JVM시작시 생성되고 프로그램이 종료될때까지 유지된다.
- Heap Area
new 를 한게 여기로 들어감 gc의 주요 대상이다
15.가비지 컬렉션
- gc를 하는 시점 
- 주요 대상은 heap 영역이다.
16.정렬, 재귀, 알고리즘의 시간 복잡도
- 재귀란?
자기 자신을 호출하는 것
- factorial을 재귀로 짜보세요
const factorial = (n) =>{
return (n -1) * factorial(n - 1)
}
17.지금까지 해본 프로젝트에 대해서 설명 해보세요.
- db에 데이터를 넣고 그것을 보내주는 기능을 만들었는데 서버는 뭘로 만들었고 클라이언트는 뭘로 만들었습니다.
사용자수는 어느정도 되었고 트래픽은 어느정도 였습니다.
18.협업을 할 때 일을 어떻게 나누었는지?
- 내가 설계를 하고 후임1 후임2에게 태스크로 어떤 작업을 할지 할당을 해주었다.
19.코드 리뷰는 어떻게 진행 했는지?
jira로 pull request를 내린다. 개발을 하기 전에 개발 방향을 먼저 회의 한다.
20.스트레스 테스트 해봤는지? 툴은 뭐 써봤는지? 결과는 어떻게 확인 하는지?
21.java8을 써보셨나요?
22.java7에서 8로 올라오면서 어떤게 달라졌나요?
23.java lambda를 써보셨나요?

1. CVS나 SVN에 대해서 아는대로 설명해 보시오.
2. 64bit CPU와 32bit CPU의 OS적 관점에서의 차이를 설명해 보시오.
3. 프로세스와 쓰레드의 차이점에 대해서 설명해 보시오.( 메모리 구조 포함 )
4. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.
5. 변수 명명법이 중요한 이유에 대해서 설명하고 예를 들어 보시오.
6. 자바의 JVM의 역할에 대해서 설명해 보시오.
7. 자바의 특징에 대해서 말해 보시오.
8. Linux에서 톰캣 환경설정을 잡는 것에 대해 설명해 보시오.
9. WAS와 웹서버의 차이점은?
10. Jquery와 Ajax에 대해 아는가?
11. 비동기와 동기 방식의 차이점에 대해서 말해보시오.(네트워크 동기,비동기 아님)
12. 개발시에 중요하다 생각하는 요소를 3가지 기술해 보시오.
13. 스프링의 MVC에 대해서 설명하시오.
14. AOP란 무엇이고 왜 사용하는지
15. ‘에자일’ 방법론에 대해서 아는가?
16. 스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.
17. 웹서버 내부 구동 방식에 대해 설명할 수 있는가?
18. 스프링 DI란?
19. UML 그려본 적 있는가?
20. Node js나 Angular JS를 사용해 본 적이 있는가?
21. 캐시와 세션의 공통점과 차이점에 대해 말해보시오.
22. 디자인 패턴 아는 것들만 간략히 설명해 보시오.
23. DataBase에서 index관련 질문이었는대 잘 모르겠어서..기억이..
24. 크롬이나 파이어폭스에서 개발도구를 사용해 디버깅을 해보았는가?
25. JDBC는 무엇인가?
26. 스프링을 사용하지 않고 MVC를 JSP에서 만들어 보았는가?
27. DB 옵티마이저에 대해 아는가?

18. 스레드는 언제쓰고 쓰레드가 무엇인가 
19. 멀티쓰레드와 쓰레드의 차이점 
20. 제네릭이란 무엇인가
21. 람다식이란 무엇인가
22. 힙과 스택의 차이점을 알고있는가

1. TCP와 UDP의 차이점
2 .http프로토콜에대해서아냐 ?
3. Sql injection을 어떻게 막을거냐?
4. 데이터베이스 설계부터 구현까지의 순서
5. 기본쿼리 테스트 ( 조인 ,아우터조인 등등..)
6. 스프링이 뭐냐
7. 프레임워크의 특징이뭐냐 
8. IOC DI AOP등…
9. 인터셉터를 어따쓰냐
10. 스프링 시큐리티써봤냐
11. 세션과 쿠키의 차이 
12. 부트스트랩이 뭔줄아냐 
13. 깃써봤냐 깃을 왜쓰냐 깃과 깃헙의 차이점이뭐냐
14. 자바스크립트가 뭐냐 스크립트언어가 뭔줄아냐
15. 제이쿼리가 뭐냐 제이쿼리의 특징
16. 제이쿼리 셀렉터 
17. 노드아냐 
18. 노드특징과 장단점을 말해봐라 
19. 동기와 비동기식의 차이점을 아냐
20. 그럼 Ajax가 뭔지 설명해봐라 
21. 콜백함수아냐
22. 클로저아냐
23. jsp가 뭔줄아냐 
24. MVC의 대해서 말해봐라 1, 2의 차이
25. RDBMS와 No SQL의 차이 
26. 기본적인 알고리즘 
27. Mybatis의 장점 

1. MVC1과 MVC2 패턴의 차이를 설명해 주세요.
2. 자바 기술로 작성된 미래가 기대되는 프레임워크와 그 이유를 설명해 주세요.
3. 다툼이 발생했을 때 이를 해결하는 당신만의 방법이 있나요? 그것을 한마디로 표현한다면?
4. 당신의 전공이 무엇인지 한 마디로 표현할 수 있나요?
5. 스프링 프레임워크의 특징에 관해 설명해 주세요.
6. 최근 관심 있는 인터넷 세상의 이슈는 무엇인가요?
7. 검색이 어떤 방식으로 작동하는지 최대한 자세히 설명해 주세요.
8. 대용량 데이터 처리를 위한 서비스 아키텍처에 대해 설명해 주세요. 그에 대한 기술도 함께 말씀해 주세요.
9. 진행 했던 프로젝트를 기술적인 측면에서 설명해 주세요.
10. 자바의 GC는 어떻게 동작하나요?
11. 정렬 알고리즘 중 가장 빠른 방식은 무엇인가요? 그 알고리즘에 대해 설명해 주세요.
12. 자바로 자판기를 설계할 때, 어떻게 설계할 것인지 설명해 주세요.

